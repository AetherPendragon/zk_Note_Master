## 4 Model II：动态功率预测与优化调度模型（决策层，可直接粘贴）

本节针对真实世界“多场景交替、负载随时间波动”的特点，在 Model I（物理层闭环放电模型）之上构建决策层：先用随机过程预测未来一段时间内的使用场景/负载，再在用户体验与热安全约束下给出可执行的功耗管理策略（如 DVFS、亮度限制、网络策略与模块开关），最终输出随时间变化的功率轨迹 \(P(t)\)、各部件占比与节能增益排序，并与 Model I 联动得到 \(SOC(t)\) 与剩余续航时间（TTE）。

### 4.1 用户行为的有限状态抽象与马尔可夫链建模

#### 4.1.1 状态集合与观测变量
我们将复杂用户行为抽象为有限场景集合（与第5节一致）：
\[
\mathcal{S}=\{S_1,S_2,S_3,S_4\}=\{\text{待机},\ \text{轻度使用},\ \text{视频流},\ \text{户外导航}\}.
\]
在每个离散决策时刻 \(t_k\)（例如每 \(\Delta t=30\sim 60\) 秒），系统可观测到或由系统统计得到特征向量
\[
x_k=[\text{Brightness}_k,\ \text{CPU负载}_k,\ \text{网络状态/信号}_k,\ \text{GPS}_k,\ T_k,\ SOC_k,\ \dots].
\]
其中部分量（如温度 \(T_k\)、\(SOC_k\)）来自 Model I 的连续时间状态更新；其余量来自系统状态（屏幕亮度、网络连接方式、GPS 开关、CPU 利用率等）。

#### 4.1.2 一阶马尔可夫假设与转移矩阵
假设用户场景切换满足一阶马尔可夫性质：
\[
\Pr(s_{k+1}=j\mid s_k=i,\ s_{k-1},\dots)=\Pr(s_{k+1}=j\mid s_k=i)=p_{ij}.
\]
令转移矩阵为 \(\mathbf{P}=[p_{ij}]_{4\times 4}\)，其中 \(p_{ij}\ge 0\)，\(\sum_j p_{ij}=1\)。

#### 4.1.3 转移概率的估计方法（可用公开数据或自定义日志）
转移矩阵可由用户行为序列（来自手机日志或公开数据集）按频数估计：
\[
\hat p_{ij}=\frac{N_{ij}}{\sum_j N_{ij}},\qquad N_{ij}=\#\{k\mid s_k=i,\ s_{k+1}=j\}.
\]
当缺乏个体用户日志时，可采用两种工程可行替代方案：

- 方案A（数据集估计）：利用公开数据集中“前台应用类别/屏幕状态/网络活动”等字段，将每个时间片归类到 \(\mathcal{S}\) 后按上式统计 \(\hat p_{ij}\)（例如用 AndroWatts 等功耗数据对“视频/导航”等类别进行映射）。
- 方案B（场景库先验）：使用第6.2节混合场景设定的场景占比作为稳态分布 \(\pi\)，并给定“停留概率高、跨越跳转低”的结构先验（例如 \(p_{ii}\) 较大、相邻场景间转移概率更大），用于生成合理的切换序列，以评估策略鲁棒性。

### 4.2 负载预测与功率序列生成（Invoke Power Submodel）
给定当前场景 \(s_k\) 与转移矩阵 \(\mathbf{P}\)，可预测未来 \(H\) 步的场景分布：
\[
\Pr(s_{k+h}=j\mid s_k=i)=[\mathbf{P}^h]_{ij},\qquad h=1,\dots,H.
\]
我们采用“滚动窗口预测（Rolling Horizon）”：在每个时刻只预测一个短窗口（例如未来 5–10 分钟），以降低误差累积，并在下一次决策时刻用最新观测更新。

对每个候选未来场景 \(s_{k+h}\)，我们调用 Model I 的部件功耗子模型（第3.3节）生成对应的期望功率：
\[
P_{\text{load}}(k+h)=P_{\text{cpu}}(u_{k+h},x_{k+h})+P_{\text{screen}}(u_{k+h},x_{k+h})+P_{\text{net}}(u_{k+h},x_{k+h})+P_{\text{gps}}(u_{k+h},x_{k+h})+P_{\text{base}},
\]
其中 \(u_{k+h}\) 为决策变量（如亮度上限、CPU 频率上限、网络模式、GPS 策略等）。若需要“概率意义下”的预测功率，可取期望：
\[
\mathbb{E}[P_{\text{load}}(k+h)\mid s_k]=\sum_{j\in\mathcal{S}}\Pr(s_{k+h}=j\mid s_k)\cdot P_{\text{load}}(j;\ u_{k+h}).
\]

此外，为满足评委对“可解释输出”的要求，我们给出部件能耗占比（可用于第5节雷达图/堆叠图）：
\[
\rho_m(k)=\frac{P_m(k)}{\sum_r P_r(k)},\qquad m\in\{\text{cpu},\text{screen},\text{net},\text{gps},\text{base}\}.
\]

### 4.3 续航最大化的优化调度（DVFS/亮度/网络/模块开关）

#### 4.3.1 优化目标：最大化 TTE 的等价形式
在离散决策窗口内，最大化 TTE 可近似转化为“在满足约束下最小化期望功率/能量消耗”。令窗口长度为 \(H\)，则目标函数可写为：
\[
\min_{u_k,\dots,u_{k+H-1}}\ \sum_{h=0}^{H-1}\mathbb{E}\big[P_{\text{load}}(k+h)\mid s_k\big]\Delta t.
\]
该形式与 Model I 的连续时间放电动力学兼容：功率越小，电流 \(I=P/U\) 越小，从而 SOC 下降越慢、TTE 越长。

#### 4.3.2 控制变量与约束（用户体验 + 热安全）
我们选取两类最直接、系统层可控的变量：

- 屏幕亮度策略：\(L_k\in[L_{\min},L_{\max}]\)
- DVFS 频率上限：\(f_k^{\max}\in[f_{\min},f_{\max}]\)

并可扩展加入：

- 网络模式（Wi-Fi/蜂窝/飞行）、数据策略（延迟同步/批处理）
- GPS 策略（保持开启/按需采样/关闭）

约束条件包括：
\[
L_k\ge L_{\min}\quad(\text{可读性约束}),
\]
\[
T_k\le T_{\max}\quad(\text{热安全约束，如 }45^\circ \text{C}),
\]
以及“性能可用性”软约束：当场景为视频/导航时需保证最低计算能力，可写为
\[
f_k^{\max}\ge f_{\text{req}}(s_k),
\]
其中 \(f_{\text{req}}\) 为不同场景的最低性能需求（可用经验阈值或由历史卡顿率/帧率目标给出）。

#### 4.3.3 可实现的近似求解：分段触发 + 贪心滚动优化
为保证策略可落地且无需复杂求解器，我们采用“规则触发 + 滚动贪心”的近似控制（符合美赛论文常见写法：清晰、可解释、能落地）：

**触发条件（低电量/高温优先）**
当满足任一条件时进入节能模式：
\[
SOC_k<SOC_{\text{th}}\quad \text{或}\quad T_k>T_{\text{th}}.
\]

**DVFS 策略（平方级收益）**  
基于第3.3节 CPU 动态功耗 \(P_{\text{cpu}}\propto V^2 f\)，且 \(V\) 随 \(f\) 增大而增大，降低频率上限能带来显著功耗下降。我们采用：
\[
f_k^{\max}=
\begin{cases}
f_{\max}, & \text{正常模式} \\
\min\big(f_{\max},\ \gamma_f f_{\max}\big), & \text{节能模式（}\gamma_f\approx 0.7\text{）}
\end{cases}
\]

**亮度策略（最大敏感因子优先压制）**  
由敏感性分析（第6节）可知 \(k_{\text{OLED}}\) 与亮度相关参数对 TTE 贡献最高，因此在节能模式优先限制亮度：
\[
L_k=
\begin{cases}
L_{\text{user}}, & \text{正常模式} \\
\max(L_{\min},\ \gamma_L L_{\text{user}}), & \text{节能模式（}\gamma_L\approx 0.6\text{）}
\end{cases}
\]

**网络/模块策略（弱信号下强约束）**  
当检测到弱信号（或网络模块处于高功率扫描/维持状态）时，执行：

- 优先 Wi-Fi 替代蜂窝；或在不可用时采用延迟同步/批处理；
- 非导航场景关闭 GPS；导航场景可由“按需采样”替代持续高频定位。

该组策略的核心思想是：在滚动窗口内优先压制对续航最敏感、且可控性最强的功耗源（屏幕与 CPU），并在弱信号场景下避免通信模块进入高功率状态，从而实现“单位体验损失下的最大续航收益”。

### 4.4 与 Model I 的耦合求解流程与输出
Model II 不直接更新 SOC，而是输出可执行控制 \(u_k\) 与预测功率轨迹；SOC、电压与温度仍由 Model I 连续时间闭环方程求解。两者在每个决策时刻按如下方式联动：

1. **观测**：从系统读取 \(x_k\)，并从 Model I 得到当前 \(SOC_k, U_{\text{cell},k}, T_k\)；
2. **预测**：用马尔可夫链得到未来窗口 \(H\) 的场景分布 \(\Pr(s_{k+h}\mid s_k)\)；
3. **优化**：在约束下求得控制序列 \(\{u_k,\dots,u_{k+H-1}\}\)（本文用触发+贪心近似）；
4. **执行**：施加当前步控制 \(u_k\)（仅执行第一步，随后滚动更新）；
5. **物理更新**：将 \(u_k\) 代入功耗模型得到 \(P_{\text{load}}(t)\)，并由 Model I 更新 \(I(t)\)、\(SOC(t)\)、\(T(t)\)；
6. **输出**：得到 \(P(t)\)、各部件占比 \(\rho_m(t)\)、\(SOC(t)\) 与 TTE，并可对不同策略进行情景对比，输出节能增益排名。

通过上述“决策层—物理层”闭环，模型不仅能在固定场景下预测续航，更能在混合场景与随机切换下给出可解释、可执行的动态节能策略，这也满足题目对“管理（management）”与“真实动态使用（dynamic usage）”的要求。
